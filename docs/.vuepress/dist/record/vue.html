<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | 记录</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="开发中常用的工具方法、css等记录">
    
    <link rel="preload" href="/eweb/assets/css/0.styles.63344b67.css" as="style"><link rel="preload" href="/eweb/assets/js/app.a69c37d8.js" as="script"><link rel="preload" href="/eweb/assets/js/2.ced4a260.js" as="script"><link rel="preload" href="/eweb/assets/js/7.0af4516f.js" as="script"><link rel="prefetch" href="/eweb/assets/js/10.90ae4c5b.js"><link rel="prefetch" href="/eweb/assets/js/11.cc97d5e5.js"><link rel="prefetch" href="/eweb/assets/js/12.0996bac8.js"><link rel="prefetch" href="/eweb/assets/js/13.ac536373.js"><link rel="prefetch" href="/eweb/assets/js/14.d97da8e5.js"><link rel="prefetch" href="/eweb/assets/js/15.7250ea31.js"><link rel="prefetch" href="/eweb/assets/js/16.d1599f13.js"><link rel="prefetch" href="/eweb/assets/js/17.7824b2dd.js"><link rel="prefetch" href="/eweb/assets/js/18.60d4d8c0.js"><link rel="prefetch" href="/eweb/assets/js/19.27c77f40.js"><link rel="prefetch" href="/eweb/assets/js/20.d5b5bf8b.js"><link rel="prefetch" href="/eweb/assets/js/21.07b697f8.js"><link rel="prefetch" href="/eweb/assets/js/22.9f87b8bf.js"><link rel="prefetch" href="/eweb/assets/js/23.e061f0ce.js"><link rel="prefetch" href="/eweb/assets/js/24.f0866f60.js"><link rel="prefetch" href="/eweb/assets/js/25.7f7f50aa.js"><link rel="prefetch" href="/eweb/assets/js/26.5a90d678.js"><link rel="prefetch" href="/eweb/assets/js/27.87518b2e.js"><link rel="prefetch" href="/eweb/assets/js/28.960f55b4.js"><link rel="prefetch" href="/eweb/assets/js/29.cd580baf.js"><link rel="prefetch" href="/eweb/assets/js/3.1a5ba184.js"><link rel="prefetch" href="/eweb/assets/js/30.78dd50b1.js"><link rel="prefetch" href="/eweb/assets/js/31.7b892cb4.js"><link rel="prefetch" href="/eweb/assets/js/32.0ffa87c4.js"><link rel="prefetch" href="/eweb/assets/js/33.ff3c9416.js"><link rel="prefetch" href="/eweb/assets/js/34.7150bfe7.js"><link rel="prefetch" href="/eweb/assets/js/35.9abeca17.js"><link rel="prefetch" href="/eweb/assets/js/36.b68c502f.js"><link rel="prefetch" href="/eweb/assets/js/37.1923871e.js"><link rel="prefetch" href="/eweb/assets/js/38.b335ec3c.js"><link rel="prefetch" href="/eweb/assets/js/39.558f67ac.js"><link rel="prefetch" href="/eweb/assets/js/4.ea209309.js"><link rel="prefetch" href="/eweb/assets/js/40.4b91b8be.js"><link rel="prefetch" href="/eweb/assets/js/41.3025ff0d.js"><link rel="prefetch" href="/eweb/assets/js/42.6ade5baa.js"><link rel="prefetch" href="/eweb/assets/js/43.da405126.js"><link rel="prefetch" href="/eweb/assets/js/44.4cd03d6c.js"><link rel="prefetch" href="/eweb/assets/js/45.618a0370.js"><link rel="prefetch" href="/eweb/assets/js/46.50f01e1a.js"><link rel="prefetch" href="/eweb/assets/js/47.b7b5910c.js"><link rel="prefetch" href="/eweb/assets/js/48.fd1908ef.js"><link rel="prefetch" href="/eweb/assets/js/5.42fbc375.js"><link rel="prefetch" href="/eweb/assets/js/6.3b0a19a2.js"><link rel="prefetch" href="/eweb/assets/js/8.3ad7b56f.js"><link rel="prefetch" href="/eweb/assets/js/9.d963c82c.js">
    <link rel="stylesheet" href="/eweb/assets/css/0.styles.63344b67.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/eweb/" class="home-link router-link-active"><!----> <span class="site-name">记录</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数据结构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/eweb/dataStructure/sparseArray.html" class="sidebar-link">稀疏数组</a></li><li><a href="/eweb/dataStructure/环形队列.html" class="sidebar-link">环形队列</a></li><li><a href="/eweb/dataStructure/单向链表.html" class="sidebar-link">单向链表</a></li><li><a href="/eweb/dataStructure/双向链表.html" class="sidebar-link">双向链表</a></li><li><a href="/eweb/dataStructure/环形链表.html" class="sidebar-link">环形链表</a></li><li><a href="/eweb/dataStructure/栈.html" class="sidebar-link">栈实现简单版计算器</a></li><li><a href="/eweb/dataStructure/逆波兰计算器的实现.html" class="sidebar-link">逆波兰计算器的实现</a></li><li><a href="/eweb/dataStructure/hashTable.html" class="sidebar-link">哈希表</a></li><li><a href="/eweb/dataStructure/tree/binaryTree.html" class="sidebar-link">二叉树基本结构</a></li><li><a href="/eweb/dataStructure/tree/arrBinaryTree.html" class="sidebar-link">顺序存储二叉树</a></li><li><a href="/eweb/dataStructure/tree/threadedBinaryTree.html" class="sidebar-link">线索化二叉树</a></li><li><a href="/eweb/dataStructure/tree/哈夫曼树.html" class="sidebar-link">哈夫曼树</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>算法笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/eweb/algorithm/NSum问题.html" class="sidebar-link">NSUM问题</a></li><li><a href="/eweb/algorithm/前缀和数组.html" class="sidebar-link">前缀和数组问题</a></li><li><a href="/eweb/algorithm/差分数组.html" class="sidebar-link">差分数组</a></li><li><a href="/eweb/algorithm/二维数组的花式遍历.html" class="sidebar-link">二维数组的花式遍历</a></li><li><a href="/eweb/algorithm/双指针技巧.html" class="sidebar-link">双指针技巧</a></li><li><a href="/eweb/algorithm/滑动窗口.html" class="sidebar-link">滑动窗口技巧</a></li><li><a href="/eweb/algorithm/递归.html" class="sidebar-link">递归</a></li><li><a href="/eweb/algorithm/linkedList/链表.html" class="sidebar-link">链表类题目</a></li><li><a href="/eweb/algorithm/sort/排序.html" class="sidebar-link">排序</a></li><li><a href="/eweb/algorithm/dynamicProgramming/动态规划01.html" class="sidebar-link">动态规划</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>js代码</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/eweb/codeSource/promise/promise.html" class="sidebar-link">promise源码</a></li><li><a href="/eweb/js相关/pub_sub_event_bus.html" class="sidebar-link">pubSub 事件总线</a></li><li><a href="/eweb/js相关/functions.html" class="sidebar-link">call apply bind debounce throttle</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/eweb/record/css.html" class="sidebar-link">CSS相关面试题</a></li><li><a href="/eweb/record/从输入URL到显示页面的过程.html" class="sidebar-link">从输入URL到显示页面的过程</a></li><li><a href="/eweb/record/http.html" class="sidebar-link">http相关</a></li><li><a href="/eweb/record/js01.html" class="sidebar-link">js 高级</a></li><li><a href="/eweb/record/vue.html" aria-current="page" class="active sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue中data为什么要是一个函数" class="sidebar-link">vue中data为什么要是一个函数</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue修饰符" class="sidebar-link">vue修饰符</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue-内部指令" class="sidebar-link">vue 内部指令</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#组件传值的方式" class="sidebar-link">组件传值的方式</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#路由模式有哪些模式-以及不同点" class="sidebar-link">路由模式有哪些模式 以及不同点</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#动态设置-class-style" class="sidebar-link">动态设置 class style</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#v-if-和-v-show的区别" class="sidebar-link">v-if 和 v-show的区别</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#computed和watch的区别" class="sidebar-link">computed和watch的区别</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#v-if和-v-for-为什么不建议用在同一标签" class="sidebar-link">v-if和 v-for 为什么不建议用在同一标签</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vuex属性及用处" class="sidebar-link">vuex属性及用处</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#不需要定义响应式数据" class="sidebar-link">不需要定义响应式数据</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#watch有哪些属性-分别有什么作用" class="sidebar-link">watch有哪些属性，分别有什么作用</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#父子组件生命周期" class="sidebar-link">父子组件生命周期</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#对象新增或删除属性无法更新视图的原因和解决方法" class="sidebar-link">对象新增或删除属性无法更新视图的原因和解决方法</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#arr-index-xx-无法更新视图" class="sidebar-link">arr[index] = xx 无法更新视图</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#自定义指令-自己用的并不多-多看下" class="sidebar-link">自定义指令 自己用的并不多，多看下</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#插槽的使用及原理-原理不是很熟悉-看这里" class="sidebar-link">插槽的使用及原理  原理不是很熟悉,看这里</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#为什么不建议-index或随机数作为key" class="sidebar-link">为什么不建议 index或随机数作为key</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#nexttick的用处" class="sidebar-link">nextTick的用处</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#nexttick-原理" class="sidebar-link">nextTick 原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#ssr-服务端渲染-这个没用过" class="sidebar-link">SSR 服务端渲染，这个没用过</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue响应式原理" class="sidebar-link">Vue响应式原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue-模板编译原理" class="sidebar-link">Vue 模板编译原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#computed和watch的原理" class="sidebar-link">computed和watch的原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue-set方法原理" class="sidebar-link">Vue.set方法原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue-delete原理" class="sidebar-link">Vue.delete原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue-检测数组变化" class="sidebar-link">Vue 检测数组变化</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#虚拟dom是什么-有什么优点" class="sidebar-link">虚拟DOM是什么 有什么优点</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#v-model原理" class="sidebar-link">v-model原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#v-for-为什么要加key" class="sidebar-link">v-for 为什么要加key</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#diff算法的原理" class="sidebar-link">diff算法的原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue事件绑定原理" class="sidebar-link">vue事件绑定原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue-router路由钩子函数的执行顺序" class="sidebar-link">vue-router路由钩子函数的执行顺序</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue-异步路由" class="sidebar-link">vue 异步路由</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue-动态路由的问题" class="sidebar-link">vue 动态路由的问题</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vuex" class="sidebar-link">vuex</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vuex刷新页面后数据会丢失" class="sidebar-link">vuex刷新页面后数据会丢失</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue中使用了哪些设计模式" class="sidebar-link">vue中使用了哪些设计模式</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue性能优化" class="sidebar-link">vue性能优化</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#nexttick-使用场景和原理" class="sidebar-link">nextTick 使用场景和原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#keep-alive-场景和原理" class="sidebar-link">keep-alive 场景和原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue-set-原理" class="sidebar-link">Vue.set 原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue-extend-原理" class="sidebar-link">Vue.extend 原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue-自定义指令" class="sidebar-link">Vue 自定义指令</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue生命周期钩子的实现原理" class="sidebar-link">Vue生命周期钩子的实现原理</a></li><li class="sidebar-sub-header"><a href="/eweb/record/vue.html#vue-router中常用的路由模式实现原理" class="sidebar-link">vue-router中常用的路由模式实现原理</a></li></ul></li><li><a href="/eweb/record/webpack5.html" class="sidebar-link">webpack相关内容</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h1> <h2 id="vue中data为什么要是一个函数"><a href="#vue中data为什么要是一个函数" class="header-anchor">#</a> vue中data为什么要是一个函数</h2> <blockquote><p>因为一个组件可能会在多个地方使用，使用data定义为函数每次调用就会执行data函数并返回一个新的对象，可以避免数据污染</p></blockquote> <h2 id="vue修饰符"><a href="#vue修饰符" class="header-anchor">#</a> vue修饰符</h2> <ol><li>.sync 目前用的最多的，子组件想修改父组件传过来的值时，通过$emit('update:propName', xxx) 父组件中 propName对应的属性会被修改为 xxx，相对于通过emit一个方法，父组件注册方法再修改值，这种方式要方便很多。</li> <li>.once 只执行一次</li> <li>.prevent 阻止默认事件，例如a标签的跳转</li> <li>.lazy 将input的input事件延迟到blur执行</li> <li>.trim 去掉输入框收尾的空格</li></ol> <h2 id="vue-内部指令"><a href="#vue-内部指令" class="header-anchor">#</a> vue 内部指令</h2> <ol><li>v-for</li> <li>v-if</li> <li>v-show</li> <li>v-model</li> <li>v-on</li> <li>v-once 元素和组件只渲染一次</li> <li>v-slot 缩写是# 插槽名</li> <li>v-pre 跳过这个元素和他的子元素的编译过程，可以用来显示原始的 Mustache标签，跳过大量没有指令的节点会加快编译速度</li> <li>v-cloak 保持在元素上直到关联实例结束编译。和css规则入 v-cloak{display:none} 一起用时，这个指令可以隐藏未编译的标签中的Mustache 直到实例准备完成</li></ol> <h2 id="组件传值的方式"><a href="#组件传值的方式" class="header-anchor">#</a> 组件传值的方式</h2> <ol><li>props 直接传递</li> <li>获取组件实例，调用方法传递，或者直接修改属性值</li> <li>eventBus</li> <li>vuex</li> <li>provide、inject</li> <li>浏览器缓存 localstorage</li></ol> <h2 id="路由模式有哪些模式-以及不同点"><a href="#路由模式有哪些模式-以及不同点" class="header-anchor">#</a> 路由模式有哪些模式 以及不同点</h2> <ol><li>hash模式：浏览器的地址栏中会有#号，通过#号后面的内容更改，触发hashchange事件，实现路由跳转</li> <li>history模式：通过pushState和replaceState切换url，实现路由切换，需要后端配合，之前用的是nginx</li></ol> <h2 id="动态设置-class-style"><a href="#动态设置-class-style" class="header-anchor">#</a> 动态设置 class style</h2> <ol><li>:class=&quot;['className', true &amp;&amp; 'classB',]&quot;</li> <li>:class=&quot;(function() {return ''})()&quot; // 还可以是一个函数 返回值是字符串 'cls1 cls2 cls3'</li> <li>:style=&quot;{height: '20px', width: getWidth(), color: isRed ? 'red' : 'black'}&quot;</li> <li>:style=&quot;[{color: textColor, fontSize: '18px'}, {xx:xx}]&quot;</li></ol> <h2 id="v-if-和-v-show的区别"><a href="#v-if-和-v-show的区别" class="header-anchor">#</a> v-if 和 v-show的区别</h2> <ol><li>v-if 会动态的删除节点或者插入节点，每一次显示隐藏都会重新跑一遍生命周期，显示隐藏决定了组件的生成和销毁</li> <li>v-show 是通过css样式控制是否显示，不会销毁</li> <li>频繁或者大数量的显隐用 v-show  否则用v-if</li></ol> <h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="header-anchor">#</a> computed和watch的区别</h2> <ol><li>computed有缓存，多个属性计算出一个值，如果多个属性没有发生变化，computed会使用缓存的值，否则重新计算。computed不支持异步</li> <li>watch是监听一个值变化，修改其他的值。可以进行异步操作</li> <li>computed 是多对一， watch是一对多</li> <li>computed传参 可以返回一个函数</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token function">cptTest</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">cptTest</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> num <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">.</span>b
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="v-if和-v-for-为什么不建议用在同一标签"><a href="#v-if和-v-for-为什么不建议用在同一标签" class="header-anchor">#</a> v-if和 v-for 为什么不建议用在同一标签</h2> <ol><li>在 vue2中 v-for 优先级高于 v-if</li> <li>会先创建出来dom，然后判断 if条件是否成立，需不需要删除dom，导致渲染了不需要的dom</li> <li>使用computed解决</li></ol> <h2 id="vuex属性及用处"><a href="#vuex属性及用处" class="header-anchor">#</a> vuex属性及用处</h2> <ol><li>State：存储数据</li> <li>Getter：允许组件从store中获取数据，mapGetters辅助函数仅仅是将store中的getter映射到局部计算属性</li> <li>Actions：与mutation沟通的桥梁，用于提交mutation，而不是直接更改状态。可以在这里做异步操作</li> <li>Mutations：唯一更改store中状态的方法，必须是同步函数</li> <li>Module：管理 store，单一的store 可以拆分成多个store且同时保存在单一的状态树中</li></ol> <h2 id="不需要定义响应式数据"><a href="#不需要定义响应式数据" class="header-anchor">#</a> 不需要定义响应式数据</h2> <ol><li>定义在data之外</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="2"><li>使用Object.freeze()冻结数据</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span>a<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token comment">// a.value无法被更改，尝试更改会报错，vue也会警告Cannot assign to read only property 'value' of object </span>
        <span class="token literal-property property">a</span><span class="token operator">:</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="watch有哪些属性-分别有什么作用"><a href="#watch有哪些属性-分别有什么作用" class="header-anchor">#</a> watch有哪些属性，分别有什么作用</h2> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">propA</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">oV<span class="token punctuation">,</span> nV</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 执行回调},</span>
        <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 是否进行深度监听</span>
        <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token comment">// 立即执行</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="父子组件生命周期"><a href="#父子组件生命周期" class="header-anchor">#</a> 父子组件生命周期</h2> <p>父 beforeCreated -&gt; 父created -&gt; 父beforeMounted -&gt; 子beforeCreated -&gt;子created -&gt; 子beforeMounted -&gt;子mounted -&gt; 父mounted
-&gt; 父beforeUpdate -&gt; 子beforeUpdate -&gt; 子update -&gt; 父update
-&gt; 父beforeDestroy -&gt; 子beforeDestry -&gt; 子destroy -&gt; 父 destroy</p> <h2 id="对象新增或删除属性无法更新视图的原因和解决方法"><a href="#对象新增或删除属性无法更新视图的原因和解决方法" class="header-anchor">#</a> 对象新增或删除属性无法更新视图的原因和解决方法</h2> <ol><li>vue没法监听到对象新增属性和删除的动作，所以就没法对新的属性进行数据劫持，自然就无法 更新视图</li> <li>$set(obj,key,v) $delete(obj, k)</li> <li>通过Vue.observable(obj) 将对象变为响应式对象，模板中要用这个方法返回的值，并且对于基本类型需要在值变化后强制刷新</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span>reactiveObj<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span>reactiveNum<span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>reactiveObj <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">observable</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>reactiveNum <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">observable</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span>
    <span class="token comment">// 后面如果修改 reactiveObj.name = '李四' ui会刷新</span>
    <span class="token comment">// 如果修改 reactiveNum 需要在值改变后调用 $fourceUpdate</span>
    
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="arr-index-xx-无法更新视图"><a href="#arr-index-xx-无法更新视图" class="header-anchor">#</a> arr[index] = xx 无法更新视图</h2> <ol><li>vue没法监视直接通过下标修改数组元素，没有对数组进行Object.defineProperty的属性劫持</li> <li>所以vue重写了 数组的7个方法来实现响应式，直接用下标的方式改为响应的方法就行</li> <li>七个方法分别是 push pop slice shift unshift reverse sort</li> <li>通过$set(arr, index, value)</li></ol> <h2 id="自定义指令-自己用的并不多-多看下"><a href="#自定义指令-自己用的并不多-多看下" class="header-anchor">#</a> 自定义指令 <a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener noreferrer">自己用的并不多，多看下<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <ol><li>bind：只会调用一次，指令第一次绑定到元素的时候调用。</li> <li>inserted：被绑定元素插入父节点时调用，既然已经插入父节点了，父节点肯定存在，但是父节点有没有被渲染出来就不知道了。即 不确定html文档中有父节点</li> <li>update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前。指令的值可能发生变化，在这里决定是否处理指令的逻辑</li> <li>componentUpdated：指令所在组件的VNode及其子VNode全部更新后调用。这里做指令的动作似乎更合理？ 需要思考下具体的应用场景</li> <li>unbind：只会调用一次，指令与元素解绑时调用。</li> <li>一个指令定义对象可以提供上面几个钩子函数，都是可选的。以上钩子均会收到下面的参数</li> <li>el：指令所在的元素，自定义标签属性传值应该是可行的。可以直接操作dom</li> <li>binding：
<ol><li>name：指令名，不包括 v- 前缀</li> <li>value：指令绑定的值 v-xxx=&quot;a&quot; ,绑定值为a。注意：a可能是个表达式、函数或者是具体的值，用到的时候要判断下，或者约定好</li> <li>oldValue：顾名思义。这个属性仅在update 和componentUpdate中可用。无论值是否改变。所以可能对比新旧值是否变化，决定要不要做指令的操作</li> <li>arg：传给指令的参数，可选。 v-xxx:foo中  参数为 &quot;foo&quot;。这个用着不是很方便，具体的忘记了。。。</li> <li>modifiers：一个包含修饰符的对象。v-xxx:foo.bar中，修饰符对象为 {foo:true, bar:true} 没用过。。</li></ol></li> <li>vnodo oldVnode</li></ol> <h2 id="插槽的使用及原理-原理不是很熟悉-看这里"><a href="#插槽的使用及原理-原理不是很熟悉-看这里" class="header-anchor">#</a> 插槽的使用及原理  <a href="https://juejin.cn/post/6949848530781470733#heading-5" target="_blank" rel="noopener noreferrer">原理不是很熟悉,看这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>有三种插槽</p> <ol><li>默认插槽</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// child</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>child<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>slot<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">&gt;</span>   
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token comment">// parent</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>parent<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>child<span class="token operator">&gt;</span>
      alskdjf 
   <span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ol start="2"><li>具名插槽</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// child</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>child<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>slot name<span class="token operator">=</span><span class="token string">&quot;one&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>slot name<span class="token operator">=</span><span class="token string">&quot;two&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token comment">// parent</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>parent<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>child<span class="token operator">&gt;</span>
      alskdjf 
      <span class="token operator">&lt;</span>span v<span class="token operator">-</span>slot<span class="token operator">:</span><span class="token string">&quot;one&quot;</span><span class="token operator">&gt;</span>这是具名插槽<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>div v<span class="token operator">-</span>slot<span class="token operator">:</span><span class="token string">&quot;two&quot;</span><span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>slot two<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ol start="3"><li>作用域插槽。父组件想用子组件的数据渲染 UI</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// child</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>child<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>slot <span class="token operator">:</span>childData<span class="token operator">=</span><span class="token string">&quot;childData&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>slot name<span class="token operator">=</span><span class="token string">&quot;two&quot;</span> <span class="token operator">:</span>data2<span class="token operator">=</span><span class="token string">&quot;childData&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token comment">// parent</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>parent<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>child<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>div v<span class="token operator">-</span>slot<span class="token operator">:</span><span class="token keyword">default</span><span class="token operator">=</span><span class="token string">'defaultSlot'</span><span class="token operator">&gt;</span>
         <span class="token punctuation">{</span><span class="token punctuation">{</span>defaultSlot<span class="token punctuation">.</span>childData<span class="token punctuation">}</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>div v<span class="token operator">-</span>slot<span class="token operator">:</span>two<span class="token operator">=</span><span class="token string">&quot;slot2Data&quot;</span><span class="token operator">&gt;</span>
         <span class="token punctuation">{</span><span class="token punctuation">{</span>slot2Data<span class="token punctuation">.</span>data2<span class="token punctuation">}</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="为什么不建议-index或随机数作为key"><a href="#为什么不建议-index或随机数作为key" class="header-anchor">#</a> 为什么不建议 index或随机数作为key</h2> <p>当列表数据顺序发生变化时，index所对应的值会变,会造成不必要的渲染，浪费性能
在数组前面插入一个值时，会重新渲染整个数组，因为index对应的值发生了变化
数组中每个对象的id 是唯一的，用id作为key就不会</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;(item,index) in list&quot;</span> <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">&quot;index&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
<span class="token keyword">let</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
list<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="nexttick的用处"><a href="#nexttick的用处" class="header-anchor">#</a> nextTick的用处</h2> <p>Vue更新dom并不是某个值发生了变化就立马去更新的，采用的<code>异步更新</code>的策略
<code>同一事件循环内</code>多次修改，会<code>统一</code>进行一次<code>视图更新</code>，这样才能节省性能
nextTick中的回调函数就是在视图更新后，下一个事件循环执行</p> <h2 id="nexttick-原理"><a href="#nexttick-原理" class="header-anchor">#</a> nextTick 原理</h2> <p>传入的回调函数被收集到 callback中</p> <p>用微任务并按照优先级优雅降级的方式实现异步刷新</p> <p>promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout</p> <h2 id="ssr-服务端渲染-这个没用过"><a href="#ssr-服务端渲染-这个没用过" class="header-anchor">#</a> SSR 服务端渲染，这个没用过</h2> <p>服务端使用Vue渲染好HTML传给前端，前端只需要渲染HTML
首次加载更快，更好的用户体验，更好的seo优化</p> <h2 id="vue响应式原理"><a href="#vue响应式原理" class="header-anchor">#</a> Vue响应式原理</h2> <p><img src="/eweb/assets/img/vue_dep_watcher.1b9a7975.png" alt="img.png">
数据劫持 + 观察者模式
vue会通过Object.defineProperty()方法，对定义在data中的属性进行劫持，数组则是通过重写数组方法来实现。
当页面使用对应属性时，每个属性都有自己的dep属性，用于存放它所依赖的watcher
在对属性进行 get的时候通过Dep收集依赖(watcher)，set的时候通过watcher触发更新。
<br>
Observer类可以将正常的对象转换为响应式对象。data中定义的每个字段，都会创建一个对应的Observer的实例
在原对象的__ob__属性上。</p> <h2 id="vue-模板编译原理"><a href="#vue-模板编译原理" class="header-anchor">#</a> Vue <a href="https://juejin.cn/post/6969563640416436232" target="_blank" rel="noopener noreferrer">模板编译原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>大概的流程是这样：扫描 template 标签中的代码，解析成抽象语法树，然后将抽象语法树转换为 render渲染函数需要的格式</p> <h2 id="computed和watch的原理"><a href="#computed和watch的原理" class="header-anchor">#</a> <a href="https://juejin.cn/post/6974293549135167495" target="_blank" rel="noopener noreferrer">computed和watch的原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <h2 id="vue-set方法原理"><a href="#vue-set方法原理" class="header-anchor">#</a> Vue.set方法原理</h2> <p>把set传入的对象变为 响应式对象，内部的defineReactive函数会执行</p> <h2 id="vue-delete原理"><a href="#vue-delete原理" class="header-anchor">#</a> Vue.delete原理</h2> <ol><li>是数组 直接调用splice方法</li> <li>判断对象本身有没有这个属性，没有就直接返回</li> <li>否则删除这个属性</li> <li>判断这个对象是不是响应式对象，不是就直接返回</li> <li>是的话就通知 视图更新 ob.dep.notify()</li></ol> <h2 id="vue-检测数组变化"><a href="#vue-检测数组变化" class="header-anchor">#</a> Vue 检测数组变化</h2> <p>通过重写数组的7种方法(push,pop,splice,shift,unshift,sort,reverse)
所以修改数组的索引和长度是无法被检测的，只有通过以上7个方法才会触发数组对应的watcher更新。
<br>push splice unshift 会往数组中增加新的值，这个值也要变成响应式的</p> <h2 id="虚拟dom是什么-有什么优点"><a href="#虚拟dom是什么-有什么优点" class="header-anchor">#</a> 虚拟DOM是什么 有什么优点</h2> <p>虚拟dom是用JavaScript对象对真实dom的一层抽象，用原生的js对象取描述一个真实的dom。</p> <p>优点：</p> <ol><li>避免手动操作dom，只要写好View-Model的代码逻辑，框架会根据虚拟dom的双向绑定，自动更新视图。</li> <li>跨平台，例如weex、服务器渲染等</li></ol> <p>缺点： 首次渲染需要生成虚拟dom对象，没有直接修改innerHTML对象</p> <h2 id="v-model原理"><a href="#v-model原理" class="header-anchor">#</a> v-model原理</h2> <p>v-model只是语法糖而已，在内部为不同的输入元素使用不同的property并抛出不同的事件</p> <ol><li>input text 使用 value和input事件</li> <li>checkbox 和radio使用 checked属性和change事件</li> <li>select 将value作为prop 并将change作为事件。</li></ol> <h2 id="v-for-为什么要加key"><a href="#v-for-为什么要加key" class="header-anchor">#</a> v-for 为什么要加key</h2> <p>让diff算法更准确、更快速</p> <ol><li>diff算法中通过对比新旧虚拟节点的key 避免就地复用的情况，所以更加准确</li> <li>利用key 的唯一性，生成map对象来获取对应节点，比遍历更快</li></ol> <h2 id="diff算法的原理"><a href="#diff算法的原理" class="header-anchor">#</a> <a href="https://juejin.cn/post/6844904113587634184#heading-0" target="_blank" rel="noopener noreferrer">diff算法的原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>vue中模板语法最终会转换为AST，当模板中某个部分发生变化时，要尽可能最小的更新dom，
通过diff算法对比，新旧虚拟节点的变化，来达到目的。
<br>
判断两个节点是否相同是比较两个节点的 标签和key是否相等
<img src="/eweb/assets/img/vue_diff.b8067114.png" alt="img.png"></p> <ol><li>新前与旧前</li> <li>新后与旧后</li></ol> <blockquote><p>1、2属于修改节点</p></blockquote> <ol start="3"><li>新后与旧前</li> <li>新前与旧后</li></ol> <blockquote><p>3、4 属于移动节点，例：列表的第二项，移动到列表的最后==</p></blockquote> <ol><li>新的第一个虚拟节点 与 旧的第一个虚拟节点比较，命中并处理后，新旧节点指针下移 继续比较下一个节点</li> <li>新的最后一个虚拟节点 与 旧的最后一个虚拟节点比较，命中并处理后，新旧节点指针往前移动，继续下一次比较</li> <li>新的最后一个虚拟节点 与 旧的第一个虚拟节点比较，命中并处理后，新的指针上移，旧的指针下移</li> <li>新的第一个虚拟节点 与 旧的最后一个虚拟节点比较，命中并处理后，新的指针下移，旧的指针上移</li> <li>都没有命中，可能是插入了新的节点、删除了旧的节点、（移动且删除了旧的节点）</li></ol> <h2 id="vue事件绑定原理"><a href="#vue事件绑定原理" class="header-anchor">#</a> vue事件绑定原理</h2> <p>原生的事件绑定是调用addEventListener绑定给真实元素的。组件事件是通过Vue的 $on实现的，基于发布订阅模式，维护一个事件中心，on的时候将事件按名称存在事件中心里，称之为订阅者，
然后emit将对应的 事件发布，执行事件中心里对应的监听器。</p> <h2 id="vue-router路由钩子函数的执行顺序"><a href="#vue-router路由钩子函数的执行顺序" class="header-anchor">#</a> vue-router路由钩子函数的执行顺序</h2> <p>钩子函数有全局守卫、路由守卫、组件守卫三种
<br>完整的导航解析流程</p> <ol><li>导航被触发</li> <li>在失活的组件中调用 beforeRouteLeave</li> <li>调用全局的beforeEach守卫</li> <li>在重用的组件中调用 beforeRouteUpdate守卫</li> <li>在路由配置中调用beforeEnter</li> <li>解析异步路由组件</li> <li>在被激活的组件中调用beforeRouteEnter</li> <li>调用全局的beforeResolve守卫</li> <li>导航被确认</li> <li>调用全局的afterEach钩子</li> <li>触发dom更新</li> <li>调用beforeRouteEnter守卫中给next的回调函数，创建好的组件实例会作为回调的参数 传入</li></ol> <h2 id="vue-异步路由"><a href="#vue-异步路由" class="header-anchor">#</a> vue 异步路由</h2> <ol><li>vue-router配置路由，可以实现按需加载，但是这种情况一个组件生成一个js文件。</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/promisedemo'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'PromiseDemo'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">componet</span><span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'../components/PromiseDemo'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="2"><li>es提案的import()</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
            <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/promisedemo'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'PromiseDemo'</span><span class="token punctuation">,</span>
            <span class="token comment">// 魔法注释的形式指定多个文件打包为一个js文件</span>
            <span class="token literal-property property">componet</span><span class="token operator">:</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: 'PromiseDemo' */</span><span class="token string">'../components/PromiseDemo'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
            <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/promisedemo2'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'PromiseDemo2'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">componet</span><span class="token operator">:</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: 'PromiseDemo' */</span><span class="token string">'../components/PromiseDemo2'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ol start="3"><li>webpack提供的require.ensure()方法，也可以实现按需加载，多个路由指定相同的chunkName，会合并为一个js文件</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/promisedemo'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'PromiseDemo'</span><span class="token punctuation">,</span>
    <span class="token comment">// 魔法注释的形式指定多个文件打包为一个js文件</span>
    <span class="token function-variable function">componet</span><span class="token operator">:</span> <span class="token parameter">r</span> <span class="token operator">=&gt;</span> require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">r</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../components/PromiseDemo'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'promsiseDemo'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/promisedemo2'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'PromiseDemo2'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">componet</span><span class="token operator">:</span> <span class="token parameter">r</span> <span class="token operator">=&gt;</span> require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">r</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../components/PromiseDemo2'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'promsiseDemo'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="vue-动态路由的问题"><a href="#vue-动态路由的问题" class="header-anchor">#</a> vue 动态路由的问题</h2> <h3 id="组件复用导致路由参数丢失的解决办法"><a href="#组件复用导致路由参数丢失的解决办法" class="header-anchor">#</a> 组件复用导致路由参数丢失的解决办法</h3> <p>因为组件复用不会触发生命周期的部分钩子，可以通过一下方式解决</p> <ol><li>监听route的变化</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">&quot;route&quot;</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token comment">// 和上面的方式一样</span>
<span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span>
        <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token parameter">toParams<span class="token punctuation">,</span> previouseParams</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>toParams<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ol start="2"><li>使用导航守卫 beforeRouteUpdate，它也可以取消导航</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'...'</span><span class="token punctuation">,</span>
    <span class="token keyword">async</span> <span class="token function">beforeRouteUpdate</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>userData <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="3"><li>:key 阻止复用</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">&quot;$route.fullPath&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="vuex"><a href="#vuex" class="header-anchor">#</a> vuex</h2> <p>vuex是专门为vue提供的全局状态管理系统，用于多个组件之间共享数据、缓存等
主要包括：
<br></p> <ol><li>State 定义应用状态的数据结构，设置默认的状态</li> <li>Getter 用于从store中获取数据</li> <li>Actions 用于提交数据到mutation，而不是直接更改数据，可以在这里做一些异步任务=</li> <li>Mutations 唯一用于更新state中的状态，且必须是同步函数</li> <li>Module 允许将单一的store拆分为多个store 且同时保存在单一的状态树中</li></ol> <h2 id="vuex刷新页面后数据会丢失"><a href="#vuex刷新页面后数据会丢失" class="header-anchor">#</a> vuex刷新页面后数据会丢失</h2> <p>需要对vuex数据持久化，一般用本地存储的方式来保存数据，vuex-persist插件就是做这个的，可以直接将state的数据保存至 cookie或者localstorage中</p> <h2 id="vue中使用了哪些设计模式"><a href="#vue中使用了哪些设计模式" class="header-anchor">#</a> vue中使用了哪些设计模式</h2> <ol><li>工厂模式 虚拟DOM根据参数的不同返回基础标签的Vnode和组件vnode</li> <li>单例模式 vuex和vue-router的插件注册方法 install判断如果系统存在实例就直接返回</li> <li>发布-订阅模式 vue事件机制</li> <li>观察者模式 响应式原理</li> <li>装饰模式 @装饰器的用法 @click @xxx 自定义指令==</li> <li>策略模式 对象的有某个行为，但在不同的场景中，该行为有不同的实现方案 比如选项的合并策略 vue中的mixin合并mergeOptions方法</li></ol> <h2 id="vue性能优化"><a href="#vue性能优化" class="header-anchor">#</a> vue性能优化</h2> <ol><li>对象层级不要过深，否则性能就会差</li> <li>不需要响应式的数据不要放到data中</li> <li>v-if和v-show区分场景使用</li> <li>computed和watch区分场景使用</li> <li>v-for遍历必须加key，key保证唯一，避免使用数组下表作为index，同时避免和v-if一起使用</li> <li>大数据列表和表格性能优化- 虚拟列表/虚拟表格</li> <li>防止内部泄露，组件销毁后把全局变量和事件销毁</li> <li>图片懒加载</li> <li>路由懒加载</li> <li>第三方插件按需引入</li> <li>适当采用keep-alive缓存组件</li> <li>防抖、节流的运用</li> <li>服务端渲染、预渲染</li></ol> <h2 id="nexttick-使用场景和原理"><a href="#nexttick-使用场景和原理" class="header-anchor">#</a> nextTick 使用场景和原理</h2> <p>修改数据之后需要获取到对应的最新dom，可以用这个方法
<br>
主要思路是采用微任务优先的方式调用异步方法取执行nextTick包装的方法
<br>
采用优雅降级的方式,
<br></p> <ol><li>先尝试使用promise</li> <li>如果没有，尝试使用 MutationObserver （这个主要是监听dom变化，也是一个异步方法）</li> <li>上面都没有，尝试使用 setImmediate</li> <li>还没有就用setTimeout</li></ol> <h2 id="keep-alive-场景和原理"><a href="#keep-alive-场景和原理" class="header-anchor">#</a> keep-alive 场景和原理</h2> <p>vue内置的组件，可以实现组件缓存。用于多个tab切换时，不会对当前组件进行卸载</p> <blockquote><p>常用的两个属性 include/exclude 允许组件有条件的进行缓存<br>
两个生命周期activated/deactivated 用来得知当前组件是否处于活跃状态<br>
keep-alive中还运用了LRU算法，选择最近最久未使用的组件予以淘汰<br></p></blockquote> <h2 id="vue-set-原理"><a href="#vue-set-原理" class="header-anchor">#</a> Vue.set 原理</h2> <p>给响应式对象新增不存在的属性时，首先会把新的属性进行响应式跟踪，然后触发对象__ob__的dep收集到的watcher取更新。
<br>当修改数组索引时，调用数组的splice方法取更新数组</p> <h2 id="vue-extend-原理"><a href="#vue-extend-原理" class="header-anchor">#</a> Vue.extend 原理</h2> <p>Vue.extend使用基础的Vue构造器，创建了一个&quot;子类&quot;。参数是一个包含组件选项的对象
<br>使用原型的继承方法返回了Vue的子类，并且利用mergeOptions把传入的options和父类的options进行了合并。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">initExtend</span><span class="token punctuation">(</span><span class="token parameter">Vue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> cid <span class="token operator">=</span> <span class="token number">0</span>
    Vue<span class="token punctuation">.</span><span class="token function-variable function">extend</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">extendOptions</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token function-variable function">Sub</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">VueComponent</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token comment">// 调用Vue初始方法</span>
        <span class="token punctuation">}</span>
        Sub<span class="token punctuation">.</span>cid <span class="token operator">=</span> cid<span class="token operator">++</span>
        <span class="token comment">// 子类原型指向父类</span>
        <span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
        <span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sub
        Sub<span class="token punctuation">.</span>options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">,</span> extendOptions<span class="token punctuation">)</span>
        <span class="token keyword">return</span> Sub
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="vue-自定义指令"><a href="#vue-自定义指令" class="header-anchor">#</a> Vue 自定义指令</h2> <p>指令本质上是装饰器，是Vue对HTML元素的扩展，给HTML元素增加自定义功能。vue编译dom时，会找到指令对象，执行指令相关方法。
<br>有五个生命周期钩子</p> <ol><li>bind：只调用一次，指令第一一次绑定到元素时调用。在这里可以做一些初始化设置。</li> <li>inserted：被绑定元素插入到父节点时调用（仅保证父节点存在，但不一定被插入到文档中）</li> <li>update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的值，可以忽略不必要的模板更新。</li> <li>componentUpdated：被绑定元素所在模板完成一次更新周期时调用。</li> <li>unbind：只调用一次，指令与元素解绑时调用</li></ol> <p>原理：</p> <ol><li>生成AST时，遇到指令会给当前元素添加 directives属性</li> <li>生成指令代码</li> <li>在patch前将指令的钩子提取到cbs中，在patch过程中调用对应的钩子</li> <li>当执行指令对应的钩子函数时，调用对应指令定义的方法</li></ol> <h2 id="vue生命周期钩子的实现原理"><a href="#vue生命周期钩子的实现原理" class="header-anchor">#</a> Vue生命周期钩子的实现原理</h2> <p>利用发布订阅模式，把用户传入的回调函数记录在数组中，之后在创建实例对象的过程中依次执行回调，
vue也是在这里保证了在vue对象实例中的this指向vm实例</p> <h2 id="vue-router中常用的路由模式实现原理"><a href="#vue-router中常用的路由模式实现原理" class="header-anchor">#</a> vue-router中常用的路由模式实现原理</h2> <h3 id="hash模式-兼容性好-但是不美观"><a href="#hash模式-兼容性好-但是不美观" class="header-anchor">#</a> hash模式 兼容性好，但是不美观</h3> <ol><li>就是url中#号后面的部分，特点是 hash虽然出现在url中，但是不会包含在http请求中，对后端没影响，因此改变hash不会重新加载页面</li> <li>可以为hash的改变添加监听事件：</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'hashchange'</span><span class="token punctuation">,</span> func<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="history模式-好看点-但是刷新会出现404-需要服务端配合-一般使用nginx将404转发到index-html-然后根据路由显示对应的页面"><a href="#history模式-好看点-但是刷新会出现404-需要服务端配合-一般使用nginx将404转发到index-html-然后根据路由显示对应的页面" class="header-anchor">#</a> history模式，好看点，但是刷新会出现404 需要服务端配合，一般使用Nginx将404转发到index.html，然后根据路由显示对应的页面</h3> <ol><li>利用了h5 History Interface 中新增的pushState和replaceState方法</li> <li>这两个方法的共同点：当调用他们修改浏览器历史记录栈后，虽然当前URL改变了，但是浏览器不会刷新</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/eweb/record/js01.html" class="prev">
        js 高级
      </a></span> <span class="next"><a href="/eweb/record/webpack5.html">
        webpack相关内容
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/eweb/assets/js/app.a69c37d8.js" defer></script><script src="/eweb/assets/js/2.ced4a260.js" defer></script><script src="/eweb/assets/js/7.0af4516f.js" defer></script>
  </body>
</html>
